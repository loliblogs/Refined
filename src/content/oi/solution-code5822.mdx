---
title: "[BZOJ3759] Hungergame"
tags: [线性基,Nim]
date: 2018-08-11
categories: [题解]
---

转载自[joyouth](https://www.cnblogs.com/joyouth/p/5334906.html)

首先我们不难看出如果存在一个异或和为 $0$ 的子集，
那么先手必胜，否则先手必败

证明如下：

1. 首先如果至少存在一个异或和为 $0$ 的子集，
那么一定存在一个异或和为 $0$ 的子集
使得选取之后剩下的数的任意子集异或和不为 $0$
2. 假设我们已经选取了一个异或和为 $0$ 的子集，
无论后手怎么做，我们总是有办法使得当前选取的子集异或和为 $0$，
因为后手无论是拿石子还是取石子之后，当前子集异或和不等于 $0$，
根据 Nim 游戏可知，此时先手一定有方案使得异或和为 $0$

至此，我们证明了如果至少存在一个异或和为 $0$ 的子集，先手必胜

那么题目就转化为求是否存在一个子集异或和为 $0$，
用线性基即可

::more

### Description

由于施惠国的统治极其残暴，
每年从 $13$ 个区中每个区中选出 $2$ 名"贡品"参加饥饿游戏，
而参加游戏的人必须在险恶的自然环境中杀死其余的人才能存活。
游戏只会有一个人活下来。
凯特尼斯•伊夫狄恩和同区的皮塔•麦拉克在历经千难万阻后活了下来，
然而残忍的游戏只允许一人存活，
正当两人准备同时吃下有毒的果实自杀的时候，统治者被打动了，
他说：你们两个人跟我玩一个游戏，你赢了，我就让你们两个都活下来。
女主角凯特尼斯•伊夫狄恩接受了挑战。

这个游戏是这样的，
有 $n$ ($n\le 20$) 个箱子，
每个箱子里面有 $a_i$ ($a_i\le 10^9$) 个石头（怎么放进去的我就不知道了），
两个人轮流进行操作（女主角先手），
每一次操作可以将任意个（大于 $0$ 个）未打开的箱子打开
（一开始所有的箱子都是关闭的），
或者在已经打开的一个箱子里拿走任意个（大于 $0$ 个）石头
（不能超过这个箱子现有的石头数）。
最后谁无法操作谁就输了。

现在给出 $n$，和这 $n$ 个箱子里的石头数 $a_i$，
女主角想知道她是否有绝对的把握取得胜利
（很明显她的对手"统治者"是绝顶聪明的）。

### Input

第一行有一个正整数 $T$（表示有 $T$ 组测试数据），
对于每组测试数据有两行，
第一行为一个正整数 $n$，
接下来有 $n$ 个数，第 $i$ 个数表示 $a_i$。

### Output

有 `T` 行：对于每一个测试数据，
如果先手可以必胜则输出 "Yes"，
否则输出 "No"（没有引号）。

### Sample Input

```plain
5
5
18 11 16 19 15
5
18 12 17 10 18
5
17 7 1 10 1
5
19 5 16 19 8
5
18 18 7 4 9
```

### Sample Output

```plain
No
Yes
Yes
Yes
Yes
```

### HINT

$100\%$ 的数据：$n\le 20$，$T\le 10$，$a_i$ 不超过 $10^9$；

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
int pos[35];
inline bool Insert(int x)
{
	int i;
	for(i=31;i>=0;--i)
	{
		if((x>>i)&1)
		{
			if(!pos[i]){pos[i]=x;break;}
			else x^=pos[i];
		}
	}
	if(x)return false;
	else return true;
}
int main(void)
{
	int i,T,n,x,ans;
	scanf("%d",&T);
	while(T--)
	{
		memset(pos,0,sizeof(pos));
		scanf("%d",&n);ans=0;
		for(i=1;i<=n;++i)
		{
			scanf("%d",&x);
			ans+=Insert(x);
		}
		if(ans)printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```
