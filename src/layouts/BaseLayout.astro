---
import { ClientRouter } from 'astro:transitions';

import { getSiteConfig } from '@/config/site.config';
import Footer from '@/components/Footer.astro';
import Navigation from '@/components/Navigation.astro';
import Sidebar from '@/components/Sidebar.astro';
import PageScrollManager from '@/components/PageScrollManager';
import MediumZoom from '@/components/MediumZoom';
import { getRssUrl, getSitemapIndexUrl } from '@/utils/collection-paths';
import getRuntimePath from '@/utils/runtime-path';

import type { PageContext } from '@/types/content';

import 'overlayscrollbars/overlayscrollbars.css';
import '@/styles/global.css';
import 'medium-zoom-next/dist/style.css';
import noscriptCssUrl from '@/styles/noscript.css?url';

interface Props {
  title?: string;
  description?: string | undefined;
  pageContext: PageContext;
}

const {
  title: pageTitle,
  description: propDescription,
  pageContext,
} = Astro.props;

// 获取全局配置 - 统一配置源
const config = getSiteConfig(pageContext.collection);

// 构建页面描述 - 直接使用传入的或默认值
const pageDescription = propDescription ?? config.description;

// 构建完整标题
const fullTitle = pageTitle ? `${pageTitle} | ${config.title}` : config.title;

const Favicon = config.favicon;
const Header = config.header;
const Analytics = config.analytics;

// 获取 runtime chunk 路径用于预加载
const runtimePath = await getRuntimePath();
---

<!DOCTYPE html>
<html lang="zh-CN" class="font-sans text-root antialiased" data-overlayscrollbars-initialize>
  <head>
    <meta charset="UTF-8" />
    <title>{fullTitle}</title>
    <meta name="author" content={config.author.name} />
    <meta name="keywords" content={config.keywords} />
    <meta name="description" content={pageDescription} />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    <link rel="dns-prefetch" href="https://giscus.app" />
    <link rel="preconnect" href="https://giscus.app" crossorigin="anonymous" />

    {runtimePath && <link rel="modulepreload" href={runtimePath} />}

    <ClientRouter />

    {/* 搜索引擎优化 */}
    <link rel="sitemap" href={getSitemapIndexUrl()} />
    {pageContext.noindex
      ? <meta name="robots" content="noindex" />
      : <link rel="canonical" href={new URL(pageContext.path, Astro.site).toString()} />}

    {/* RSS 订阅 */}
    <link rel="alternate" href={getRssUrl(pageContext.collection)} title={config.title} type="application/rss+xml" />

    {/* 网站图标 */}
    <Favicon />

    {/* 顶部组件 */}
    {Header && <Header />}

    {/* 主题颜色 */}
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)" />
    <meta name="theme-color" content="#2b2e32" media="(prefers-color-scheme: dark)" />
    <meta name="color-scheme" content="light dark" />

    {/* MathJax CSS - 配置层预处理的样式 */}
    {config.mathCSS && <style set:html={config.mathCSS} />}

    {/* 重定向 */}
    {pageContext.redirect && (
      <meta
        http-equiv="refresh"
        content={[
          pageContext.redirect.timeout,
          pageContext.redirect.to && `url=${pageContext.redirect.to}`,
        ].filter(Boolean).join('; ')}
      />
    )}

    {/* 无 JS 时恢复原生滚动条 */}
    <noscript>
      <link rel="stylesheet" href={noscriptCssUrl} />
    </noscript>
  </head>

  <body class="bg-surface leading-relaxed text-primary">
    <main class="
      flex h-viewport-height flex-col
      print:h-auto
    "
    >
      <header
        id="header"
        class="
          fixed inset-y-0 left-0 flex w-header
          max-lg:static max-lg:h-0 max-lg:w-full
          print:static print:h-auto print:w-full
        "
      >
        {/*
          * 控制 checkbox 放在 header 级别：
          * 1. 确保遮罩层 z-index 不被子组件 stacking context 限制
          * 2. CSS 兄弟选择器 ~ 可以跨组件选择 nav/aside 内的元素
          * 3. Tailwind 不支持跨组件的 peer 变体，需用任意值语法 [#id:checked~#target_&]
          */}
        <input type="checkbox" id="sidebar-toggle" class="sr-only" aria-label="切换侧边栏" />
        <input type="checkbox" id="menu-toggle" class="sr-only" aria-label="切换菜单" />

        {/* 菜单透明遮罩 - 必须在 nav 外部才能正确覆盖全屏 */}
        <label
          for="menu-toggle"
          id="nav-menu-mask"
          class="
            pointer-events-none fixed inset-0 z-9 hidden bg-transparent
            max-lg:block
            lg:hidden
            print:hidden
            max-lg:[#menu-toggle:checked~&]:pointer-events-auto
          "
        >
          <span class="sr-only">关闭菜单</span>
        </label>

        <Navigation
          transition:name="navigation"
          collection={pageContext.collection}
        />

        {Astro.slots.has('sidebar')
          ? (
              <Sidebar
                transition:animate={config.animationNew}
                transition:name="aside"
                pageContext={pageContext}
              >
                <slot name="sidebar" />
              </Sidebar>
            )
          : (
              <Sidebar
                transition:animate={config.animationNew}
                transition:name="aside"
                pageContext={pageContext}
              />
            )}
      </header>
      <div
        id="content"
        class="
          ml-header flex min-h-0 flex-1 overflow-y-auto px-8 pt-8 pb-2
          max-lg:ml-0 max-lg:px-4 max-lg:pt-17 max-lg:pb-1.5
          print:ml-0 print:pt-4
        "
        transition:name="content"
        transition:animate={config.animationNew}
        data-overlayscrollbars-initialize
      >
        <div
          id="wrapper"
          class="
            mx-auto flex min-h-full w-full max-w-content-max flex-col
            print:min-h-0 print:max-w-none
          "
        >
          <div class="grow">
            <slot />
          </div>
          <div class="mt-auto">
            <Footer transition:name="footer" pageContext={pageContext} />
          </div>
        </div>
        <MediumZoom client:idle />
        <PageScrollManager client:idle />
      </div>
    </main>
    {Analytics && <Analytics />}
    {/*
      手动控制页面切换动画，而不是用 transition:animate API
      原因：transition:animate 在 fetch 完成后才播放，用户点击链接会感知延迟
      这里在 before-preparation（fetch 前）就开始播放退出动画，提升响应速度
    */}
    {/* eslint-disable @stylistic/jsx-one-expression-per-line */}
    <script
      is:inline
      define:vars={{
        animationOld: config.animationOld.name,
        minAnimationMs: config.animationOld.minAnimationMs,
      }}
    >
      document.addEventListener('astro:before-preparation', (e) => {
        // 立即开始退出动画
        const aside = document.getElementById('aside-inner');
        const content = document.getElementById('content');
        aside?.classList.add(animationOld);
        content?.classList.add(animationOld);

        // 劫持 loader：并行执行 fetch + 最小等待时间
        // 这样既不阻塞网络请求，又保证动画至少播放指定时间
        const originalLoader = e.loader;
        e.loader = async () => {
          await Promise.all([
            originalLoader(),
            new Promise(resolve => setTimeout(resolve, minAnimationMs)),
          ]);
        };
      });
    </script>
    {/* eslint-enable @stylistic/jsx-one-expression-per-line */}
  </body>
</html>
