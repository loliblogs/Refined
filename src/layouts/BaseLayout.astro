---
import { ClientRouter } from 'astro:transitions';

import { getSiteConfig } from '@/config/site.config';
import Footer from '@/components/Footer.astro';
import Navigation from '@/components/Navigation.astro';
import Sidebar from '@/components/Sidebar.astro';
import PageScrollManager from '@/components/PageScrollManager';
import MediumZoom from '@/components/MediumZoom';
import { getRssUrl, getSitemapIndexUrl, getSearchBundlePath } from '@/utils/collection-paths';
import getRuntimePath from '@/utils/runtime-path';

import type { PageContext } from '@/types/content';

import 'overlayscrollbars/overlayscrollbars.css';
import '@/styles/global.css';
import 'medium-zoom-next/dist/style.css';
import noscriptCssUrl from '@/styles/noscript.css?url';
import mathjaxCss from '@/styles/mathjax.css?inline';
import jbMonoNormalUrl from '@fontsource-variable/jetbrains-mono/files/jetbrains-mono-latin-wght-normal.woff2?url';
import jbMonoItalicUrl from '@fontsource-variable/jetbrains-mono/files/jetbrains-mono-latin-wght-italic.woff2?url';

interface Props {
  title?: string;
  description?: string | undefined;
  pageContext: PageContext;
}

const {
  title: pageTitle,
  description: propDescription,
  pageContext,
} = Astro.props;

// 获取全局配置 - 统一配置源
const config = getSiteConfig(pageContext.collection);

// 构建页面描述 - 直接使用传入的或默认值
const pageDescription = propDescription ?? config.description;

// 构建完整标题
const fullTitle = pageTitle ? `${pageTitle} | ${config.title}` : config.title;

const Favicon = config.favicon;
const Header = config.header;
const Analytics = config.analytics;

// 获取 runtime chunk 路径用于预加载
const runtimePath = await getRuntimePath();
---

<!DOCTYPE html>
<html lang="zh-CN" class="font-sans text-root antialiased" data-overlayscrollbars-initialize>
  <head>
    <meta charset="UTF-8" />
    <title>{fullTitle}</title>
    <meta name="author" content={config.author.name} />
    <meta name="keywords" content={config.keywords} />
    <meta name="description" content={pageDescription} />
    <meta name="viewport" content="width=device-width,initial-scale=1" />

    {/* 字体预加载 - HTML parse 阶段立即下载，与 CSS bundle 并行 */}
    <link rel="preload" href={jbMonoNormalUrl} as="font" type="font/woff2" crossorigin />
    <link rel="preload" href={jbMonoItalicUrl} as="font" type="font/woff2" crossorigin />
    {/* MathJax @font-face 内联 - 配合 rehype 的 inline style 让浏览器在 parse 阶段匹配字体 */}
    <style set:html={mathjaxCss} />

    <link rel="dns-prefetch" href="https://giscus.app" />
    <link rel="preconnect" href="https://giscus.app" crossorigin="anonymous" />

    {runtimePath && <link rel="modulepreload" href={runtimePath} />}

    {pageContext.preloadSearch && (
      <link rel="modulepreload" href={`${getSearchBundlePath(pageContext.collection)}pagefind.js`} crossorigin />
    )}

    <ClientRouter />

    {/* 搜索引擎优化 */}
    <link rel="sitemap" href={getSitemapIndexUrl()} />
    {pageContext.noindex
      ? <meta name="robots" content="noindex" />
      : <link rel="canonical" href={new URL(pageContext.path, Astro.site).toString()} />}

    {/* RSS 订阅 */}
    <link rel="alternate" href={getRssUrl(pageContext.collection)} title={config.title} type="application/rss+xml" />

    {/* 网站图标 */}
    <Favicon />

    {/* 顶部组件 */}
    {Header && <Header />}

    {/* 主题颜色 */}
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)" />
    <meta name="theme-color" content="#2b2e32" media="(prefers-color-scheme: dark)" />
    <meta name="color-scheme" content="light dark" />

    {/* MathJax CSS - 配置层预处理的样式 */}
    {config.mathCSS && <style set:html={config.mathCSS} />}

    {/* 重定向 */}
    {pageContext.redirect && (
      <meta
        http-equiv="refresh"
        content={[
          pageContext.redirect.timeout,
          pageContext.redirect.to && `url=${pageContext.redirect.to}`,
        ].filter(Boolean).join('; ')}
      />
    )}

    {/* 无 JS 时恢复原生滚动条 */}
    <noscript>
      <link rel="stylesheet" href={noscriptCssUrl} />
    </noscript>
  </head>

  <body class="bg-surface leading-relaxed text-primary">
    {/* Focus trap: body 层级，永远不受 OverlayScrollbars DOM 操作影响，避免 focus() 触发脏样式重算 */}
    <div
      data-focus-trap
      tabindex="-1"
      role="presentation"
      class="absolute size-0 overflow-hidden contain-strict"
    />
    <main class="
      flex h-viewport-height flex-col
      print:h-auto
    "
    >
      <div
        data-content
        class="
          ml-header min-h-0 flex-1
          max-lg:ml-0
          print:ml-0
        "
        transition:name="content"
        transition:animate={config.animationNew}
      >
        <div
          data-content-viewport
          class="flex h-full flex-col overflow-y-auto contain-content"
          data-overlayscrollbars-initialize
        >
          {/* wrapper */}
          <div
            class="
              mx-auto flex w-full max-w-content-max grow flex-col px-8 pt-8 pb-2
              max-lg:px-4 max-lg:pt-17 max-lg:pb-1.5
              print:max-w-none print:grow-0 print:pt-4
            "
          >
            <div class="grow">
              <slot />
            </div>
            <div class="mt-auto">
              <Footer pageContext={pageContext} />
            </div>
          </div>
        </div>
        <MediumZoom client:idle />
        <PageScrollManager client:idle />
      </div>
      <header
        class="
          fixed inset-y-0 left-0 flex w-header
          max-lg:static max-lg:h-0 max-lg:w-full
          print:static print:order-first print:h-auto print:w-full
        "
      >
        {/*
          * 控制 checkbox 放在 header 级别：
          * 1. 确保遮罩层 z-index 不被子组件 stacking context 限制
          * 2. CSS 兄弟选择器 ~ 可以跨组件选择 nav/aside 内的元素
          * 3. Tailwind 不支持跨组件的 peer 变体，需用任意值语法 [#id:checked~#target_&]
          * 4. input 自身作为遮罩，点击即 toggle，避免多个 label 指向同一 input 的 a11y 问题
          */}
        <input
          type="checkbox"
          id="--sidebar-toggle"
          class="
            pointer-events-none fixed inset-0 z-89 hidden cursor-pointer
            appearance-none bg-overlay opacity-0 transition-opacity
            checked:pointer-events-auto checked:opacity-100
            max-lg:block
            lg:hidden
            print:hidden
          "
          aria-label="切换侧边栏"
        />
        <input
          type="checkbox"
          id="--menu-toggle"
          class="
            pointer-events-none fixed inset-0 z-9 hidden cursor-pointer
            appearance-none bg-transparent
            checked:pointer-events-auto
            max-lg:block
            lg:hidden
            print:hidden
          "
          aria-label="切换菜单"
        />

        <Navigation collection={pageContext.collection} />

        {Astro.slots.has('sidebar')
          ? (
              <Sidebar
                transition:animate={config.animationNew}
                transition:name="aside"
                pageContext={pageContext}
              >
                <slot name="sidebar" />
              </Sidebar>
            )
          : (
              <Sidebar
                transition:animate={config.animationNew}
                transition:name="aside"
                pageContext={pageContext}
              />
            )}
      </header>
    </main>
    {Analytics && <Analytics />}
    {/*
      手动控制页面切换动画，而不是用 transition:animate API
      原因：transition:animate 在 fetch 完成后才播放，用户点击链接会感知延迟
      这里在 before-preparation（fetch 前）就开始播放退出动画，提升响应速度
    */}
    {/* eslint-disable @stylistic/jsx-one-expression-per-line */}
    <script
      is:inline
      define:vars={{
        animationOld: config.animationOld.name,
        minAnimationMs: config.animationOld.minAnimationMs,
      }}
    >
      document.addEventListener('astro:before-preparation', (e) => {
        // 立即开始退出动画
        const aside = document.querySelector('[data-aside-inner]');
        const content = document.querySelector('[data-content]');
        aside?.classList.add(animationOld);
        content?.classList.add(animationOld);

        // 劫持 loader：并行执行 fetch + 最小等待时间
        // reduced-motion 或 update:slow 用户不等待（动画类已用 motion-safe:update-fast: 前缀）
        const skipAnimation = matchMedia('(prefers-reduced-motion: reduce), (update: slow)').matches;
        const originalLoader = e.loader;
        e.loader = async () => {
          await Promise.all([
            originalLoader(),
            !skipAnimation && new Promise(resolve => setTimeout(resolve, minAnimationMs)),
          ]);
        };
      });
    </script>
    {/* eslint-enable @stylistic/jsx-one-expression-per-line */}
  </body>
</html>
